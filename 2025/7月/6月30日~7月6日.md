# エンジニアキャリアログ(2025/6/30〜2025/7/6)
## フリーランスとして新案件開始 & 環境構築
フロントエンド、バックエンド、インフラが全て1つのリポジトリのモノレポ。
### bash前提のプロジェクトだけどデフォルトシェルをzshから変えたくない
新案件のプロジェクトの環境は全てbash前提。でも私のMacのデフォルトシェルはzsh。デフォルトシェルをbashに変えるのはいろいろと面倒。

ふだんはターミナルとして[warp](https://www.warp.dev/)を使っているので、[iTerm2](https://iterm2.com/)をインストールしてiTerm2ではbashを使うよう設定。

### プロジェクトのバージョン管理はasdfだけど、上位互換のmiseを使う
プロジェクトのNode.jsなどのバージョン管理は[asdf](https://asdf-vm.com/)だが、asdfの後継で上位互換の[mise](https://mise.jdx.dev/getting-started.html)を利用。Rust製で速いし、[direnv](https://direnv.net/)的な機能もあってasdfより快適。

### 環境構築手順の古い部分を修正
- `Brewfile`から`tap "homebrew/bundle"`を削除。`bundle`は`homebrew`本体に統合済のため
- Ktorのビルドが失敗する。プロジェクトのKotlinバージョンがK2コンパイラーに対応していないため → 手順書にK2コンパイラーをオフにするよう理由とともに明記
- フロントエンドとバックエンドの疎通ができない。手順書のバックエンドのポート番号が違うため → 正しいポート番号に修正

### Linguiで多言語対応ファイル自動生成
[Lingui](https://lingui.dev/)というツールで多言語対応用の言語ファイルを自動生成している。個人開発でも多言語対応をやっているので、公式ドキュメント読んで良さげだったら個人開発にも導入したい。

### GraphQL初体験
実務でも個人でも[GraphQL](https://graphql.org/)の経験はゼロ。でもこのプロジェクトでフロントエンドとバックエンドのやりとりは全てGraphQL。使いながら覚えていく。

GraphQLはざっくりいうと、レスポンスで返してほしいものだけをリクエストで厳密に指定できるAPIクエリ言語。RESTだったらたとえば`/user?id=1`みたいなGetリクエストを投げるとユーザーの名前や住所、電話番号など全てのユーザー情報が取れる。

でも名前だけが必要な場合、RESTだと住所や電話番号などは無駄な情報になる。一方GraphQLなら
```graphql
{
  user {
    name
  }
}
```
とリクエストを投げれば、
```graphql
{
  "data": {
    "user": {
      "name": "taro"
    }
  }
}
```
のように必要な情報だけを取れるので通信に無駄がない。SPAで必要な情報が画面やコンポーネントごとに微妙に異なる場合にGraphQLが適している。

GraphQLではRESTのGetにあたるものが`Query`、Postにあたるものが`Mutation`と言われる。

## タスク：バックエンドでユーザーパスワードのエラーハンドリングが不十分
バックエンドでは`abc12345@`のような、連続する英数字などの予測されやすいユーザーパスワードは弾いている。だがエラーハンドリングが不十分なので、フロントエンドで「パスワードに問題があります。」というユーザーがどうすべきかわからないメッセージが出ている。

パスワードエラーの種類によってエラーハンドリングを適切に行い、メッセージは「単純なパスワードは使用できません。例:Abc123asdf!、P@ssword111」に修正。

## タスク：生産終了した製品した製品を区別できるようにする
製品検索画面で生産終了した製品が区別できない。なので、
- DBに生産終了を区別できるカラム追加
- バックエンド、フロントエンドの追加カラムに関するコード修正
- 製品検索やその他関連画面で生産終了を区別できるUIの検討と実装

を実施。UIは見た目にわかりやすく、既存レイアウトへ影響少なく導入しやすい`生産終了バッジ`を採用。`shadcn/ui`で手軽に作成。

## 個人開発：ecspressoのインプット
ECSタスク定義やECSサービスをTerraform管理するのはつらい。なぜならECSタスク定義のタグが頻繁に変わるので、タグが変わるたびに`terraform apply`をしなくちゃいけない。かといってタグを`ignore_changes`したらTerraform管理をする意味がない。

ECSタスク定義、ECSサービスのTerraform管理をやめ、[ecspresso](https://github.com/kayac/ecspresso)
管理にすることでこの問題を解決できる。具体的には以下の運用。

- ECSタスク定義をデプロイ時にGitHub Actionsでパラメーターストアに登録しているECSタスク定義のタグを更新
- ecspressoでタグはパラメーターストアから動的読み込み